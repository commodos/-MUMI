function [uOutput,t,f,lines,options] = GenerateSignal(varargin)
% GenerateSignal generates tailored multisines
% usage:
%   GenerateSignal(N,NInputchannels,P,M,fs,fmin,fmax,OTHER PARAMETERS)
% OR 
%   GenerateSignal(OPTIONS) called by OPTIONS structure (see later on)
% Parameters:
% N: # number of samples per period (default 1024)
% NInputchannels: # number of input channels (default 1)
% P: # periods (default 3)
% M: # realizations (default 7)
% fs: sampling frequency (Hz) (default 1024)
% fmin: minimum excited frequency (Hz) (default 1)
% fmax: maximum excited frequency (Hz) (default 0.4*fs)
% OTHER PARAMETERS, use in ('ParameterType',Value) format 
% plot: if 1, then a figure is created with the signal
% phaseType: 'random' (default), 'schroeder', 'linear'
% tau: in case of 'linear' phase, default is 1
% missingHarmonics: null (full band multisine) othwersie odd multisine: 
%  'random' (1 out of Fgroup), or a number (missingHarmonics-th harmics are skiped) default is nothing (fully excited spectrum)
% Fgroup: number of odd harmonics in a group, default 3
% rms: rms value of the excitation signal (default is 1)
% maxAmplitude: maximum amplitude (rms is set by default)
% channel_mode: 1 (default): orthogonal MS, 0 hadamard with
%  chanelwise new MS, -1: hadamard with one varying MS, 2: full orthogonal multisines
% plot: optional plot of the generated signal: (0) no, (1) yes
% CFoptimization: crest factor optimization, default 0
% enforcefminfmax: enforce fmin and fmax in case of missing/random odd ms
% nIter: iteration for CF minimization, defult 1000
% gain_on_lines: shape the magnite characteristics of the excitation 1xfloor(N/2) vector, default is [1..1] 
%
%
% OUTPUT Parameters
% uOutput: generated multisine signal
% t: time domain vector for the P periods signal,[1 X M*P*N]
% f: frequency vector for the dft of 1 period, dim. [1 x N]
% lines: indecies of excited lines
% options: OPTIONS structure
%
% OPTIONS is a structure that contains all the above mentioned
% parameters. It can be handy to use this when later analyzing the
% measurments (or designing new experiments)
%
% Examples:
%  1. GenerateSignal(2048,2,3,7,512,'plot',1)
%  This generates and plots multisines with 2048 samples per period, 
%  for 2 inputs with 3 periods, 7 realizations, 
%  with a sampling frequency of 512 Hz
%
%  2. GenerateSignal(2048,3,1,1,'phaseType','schroeder','plot',1)
%  This generates and plots Schroeder phase multisines for 3 inputs, with 1
%  period/realization
%
% Copyright (c) Dr. Péter Zoltán Csurcsia, Vrije Universiteit Brussel, 
% First creation: January 2010
% Last modified: November 2021
% For more information related licensing, see license.txt
%
Test_settings;   % this file includes the default settings
defaultmode=0;

% Processing the input parameters
Nvar=length(varargin);
if Nvar==0 
    warning('No input paramters found. Signal is generated by the use of default parameters');
    defaultmode=1;
    options=[];
elseif Nvar==1 && ~isnumeric(varargin{1})
    options=varargin{1};
else
    for i = 1:Nvar
        if isnumeric(varargin{i}) 
           if i==1, 
               options.N=varargin{i}; 
           elseif isnumeric(varargin{i-1})
               switch i
                   case 1, options.N=varargin{i};
                   case 2, options.NInputchannels=varargin{i};
                   case 3, options.P=varargin{i};
                   case 4, options.M=varargin{i};
                   case 5, options.fs=varargin{i};
                   case 6, options.fmin=varargin{i};
                   case 7, options.fmax=varargin{i};                   
               end
           end
        elseif i>1 && i<=Nvar-1
            if ~isnumeric(varargin{i})
                options=setfield(options,varargin{i},varargin{i+1});
                i=i+1;
            end
        end        
    end    
end




%% check input parameters-options
if(~isfield(options,'N')) %length of period
    try 
        options.N=Test.N; %default from the settings file
    catch
        options.N=1024; 
    end
end

if(~isfield(options,'onlyOdd')) 
    try 
        if defaultmode 
            if strcmp(upper(Test.Mode),'ROBUST') 
                options.onlyOdd=0; 
            else 
                options.onlyOdd=1; 
            end; 
        end; 
    end; 
end

if(~isfield(options,'onlyOdd')) 
    options.onlyOdd=0; 
end
if(~isfield(options,'P') && ~isfield(options,'P'))
    try
        options.P=eval(sprintf('Test.%s.P',Test.Mode));
        options.M=eval(sprintf('Test.%s.M',Test.Mode));
    catch
        options.P=3;
        options.M=7;
    end
end
if(~isfield(options,'P')) 
    try 
        options.P=eval(sprintf('Test.%s.P',Test.Mode)); 
    catch
        options.P=3; 
    end; 
end
if(~isfield(options,'M')) 
    try 
        options.M=eval(sprintf('Test.%s.M',Test.Mode)); 
    catch
        options.M=7; 
    end; 
end
if(~isfield(options,'fs')) 
    try 
        options.fs=Test.fs; 
    catch
        options.fs=1024; 
    end
    if(~isfield(options,'fmin')) 
        try 
            options.fmin=Test.fmin; 
        catch
            options.fmin=options.fs/options.N; 
        end; 
    end
    if(~isfield(options,'fmax')) 
        try 
            options.fmax=Test.fmax; 
        catch
            options.fmax=options.fs*0.4; 
        end; 
    end
else
    if(~isfield(options,'fmin')) 
        options.fmin=options.fs/options.N; 
    end
    if(~isfield(options,'fmax')) 
        options.fmax=options.fs*0.4; 
    end
end
if(~isfield(options,'plot')) 
    try 
        options.plot=Test.plot; 
    catch
        options.plot=1; 
    end
end
if(~isfield(options,'gain_on_lines')) 
    options.gain_on_lines=ones(1,floor(options.N/2)); 
end

    
if(~isfield(options,'rms')) 
    try 
        if Test.NormalizeToRMS 
            options.rms=Test.NormalizationValue; 
        end
    catch options.rms=1; 
    end; 
end

if(isfield(options,'maxAmplitude'))   
    if(options.maxAmplitude>0)
        options.rms=0;
    end
end

if(~isfield(options,'phaseType')) 
    options.phaseType='random'; 
end
if(~isfield(options,'tau')) 
    options.tau=1; 
end
if(~isfield(options,'CFoptimization')) 
    try 
        options.CFoptimization=Test.CFoptimization; 
    catch
        options.CFoptimization=0; 
    end; 
end

if(~isfield(options,'nIter')) % number of iterations for CF optimization
    options.nIter=1000; end % 
if(~isfield(options,'Fgroup')) 
    options.Fgroup=3; 
end
if(~isfield(options,'NInputchannels')) 
    try 
        options.NInputchannels=Test.NInputchannels;
    catch
        options.NInputchannels=1;
    end 
end
if(~isfield(options,'channel_mode')) 
    options.channel_mode=1; 
end
if(~isfield(options,'enforcefminfmax')) 
    try 
        options.enforcefminfmax=Test.enforcefminfmax; 
    catch
        options.enforcefminfmax=0;
    end
end


if options.onlyOdd  
    if(~isfield(options,'missingHarmonics'))   
        options.missingHarmonics='random'; 
    end
end

%% Creation of the output
% initialize the output
uOutput=zeros(options.NInputchannels,options.N*options.P*options.M*options.NInputchannels);

% decorrelation technique 
if(options.channel_mode<=0)
    W=hadamard(pow2(ceil(log2(options.NInputchannels))));
    W=W(1:options.NInputchannels,1:options.NInputchannels);
elseif(options.channel_mode==1)
    for index_k=1:options.NInputchannels
       for index_n=1:options.NInputchannels
            W(index_k,index_n)=exp(-1j*2*pi*(index_k-1)*(index_n-1)/options.NInputchannels);
       end
    end    
elseif(options.channel_mode==2)
    for index_k=1:options.NInputchannels
       phaseshift=rand(1,options.NInputchannels)*2*pi;    
       for index_n=1:options.NInputchannels
            W(index_k,index_n)=exp(-1j*phaseshift(index_n));
       end
    end 
end

% fundamental frequency
f0 = options.fs/options.N;

% excited lines
lines = (ceil(options.fmin/f0):floor(options.fmax/f0))+1;

if(options.onlyOdd==1)    
    lines= 2*round((floor(options.fmin/f0)+1)/2):2:2*round((floor(options.fmax/f0)+1)/2);    
end

% harmonic mode
if(isfield(options,'missingHarmonics'))    
    if strcmp(upper(options.missingHarmonics),'RANDOM')                      
                
        randomHarmonics=[randi([1,options.Fgroup],1,floor(options.N/(options.Fgroup*2)))*2]+[0:(options.Fgroup*2):(floor(options.N/(options.Fgroup*2))-1)*(options.Fgroup*2)];
        
        if options.enforcefminfmax 
            if randomHarmonics(1)==2 randomHarmonics(1)=4; end
            if randomHarmonics(end)==(floor(options.N/(options.Fgroup*2)))*(options.Fgroup*2) randomHarmonics(end)=(floor(options.N/(options.Fgroup*2)))*(options.Fgroup*2)-2; end
        end
        
        for i=1:length(randomHarmonics)
           for j=1:length(lines)
             if(lines(j)==randomHarmonics(i))
                 lines(j)=[];
                 break;
             end
           end
        end
    else
        for i=options.missingHarmonics+1:options.Fgroup*2:options.N
            for j=1:length(lines)
             if (lines(j)==i) && ~(j==1 && options.enforcefminfmax) && ~(j==length(lines) && options.enforcefminfmax)                 
                 lines(j)=[];
                 break;
             end
            end
        end
    end
end

% frequency lines
f = 0:f0:options.fs-f0;

options.gain_on_lines=interp1(1:floor(options.N/2),options.gain_on_lines,lines);

for index_k=1:options.NInputchannels
    %% generate random phase multisine
    % to generate for each input chanel a new multisine, expect when
    % Hadamard is used
    if((index_k==1 && options.channel_mode==-1) || options.channel_mode>=0)
        if options.CFoptimization==0 % if there is no CF optimization
            U =generateMultiSine(options.N,options.M,options.phaseType,f0,options.tau,lines,options.gain_on_lines);
            u = 2*real(ifft(U,[],2));
        else % if there is CF optimization
            best_CF = 10;
            for i = 1:options.nIter
                U = generateMultiSine(options.N,options.M,options.phaseType,f0,options.tau,lines,options.gain_on_lines);
                u= 2*real(ifft(U,[],2));
                CF = max(abs(reshape(u.',1,options.N*options.M)))/rms(reshape(u.',1,options.N*options.M));
                if CF < best_CF
                    best_CF = CF;
                    ubest = u;
                    Ubest = U;
                end
            end
            u=ubest;
            U=Ubest;
        end
        CF = max(abs(reshape(u.',1,options.N*options.M)))/rms(reshape(u.',1,options.N*options.M)');
    end
    
    % generating the final output
    for index_n=1:options.NInputchannels
        %% finial output 
        U=  W(index_k,index_n)*U;
        u = real(ifft(U,[],2));

        u = repmat(u,1,options.P);
        u=reshape(u.',1,options.N*options.P*options.M);
        
        if(options.rms>0)
            u=options.rms*u/rms(u.');
        else
            u=u/max(abs(u));
        end
                
        uOutput(index_k,(index_n-1)*options.N*options.P*options.M+1:index_n*options.N*options.P*options.M)=u;
    end
end

    % time lines
    t=[0:length(uOutput(1,:))-1]/options.fs;


%% plots - optional
if options.plot==1
    
    display(sprintf('measurement time is %f seconds',max(t)));
    if isfield(options,'missingHarmonics') Nsubplots=3; else Nsubplots=2; end;
    
    figure('units','normalized','outerposition',[0 0 1 1])
    figure_nr=1;
    for index_k=1:options.NInputchannels
        subplot(options.NInputchannels,Nsubplots,figure_nr);
        plot(t,uOutput(index_k,:)); grid on;
        xlabel('time (s)')
        ylabel(sprintf('Channel %i',index_k))
        title('time domain signal')
        xlim([min(t) max(t)])
        figure_nr=figure_nr+1;
        
        Up=fft(uOutput(index_k,1:options.N))/sqrt(options.N);

        subplot(options.NInputchannels,Nsubplots,figure_nr); 
        hold on;
        plot(f,db(Up),'.-','MarkerSize',20); grid on;
        xlabel('frequency (Hz)');
        ylabel('magnitude (dBV)');
        title('frequency domain');
        xlim([0-options.fs/options.N options.fs/2])
        ylim([min(db(Up))-20 max(db(Up))+10]);
        figure_nr=figure_nr+1;

        if Nsubplots==3            
            subplot(options.NInputchannels,Nsubplots,figure_nr); grid on
            hold on;
            for i=2:options.Fgroup*2:options.N
                dbUp=db(Up(i:min(options.N,i+options.Fgroup*2)));
                dbUp(find(dbUp==-inf))=-320;
                plot(f(i:min(options.N,i+options.Fgroup*2)),dbUp,'.', 'MarkerSize',30);
            end
            xlabel('frequency (Hz)');
            ylabel('magnitude (dBV)');
            title('first blocks');
            xlim([options.fmin-f0/2 options.fmin+((4*options.Fgroup*2)-1)*f0])
            ylim([min(db(Up))-20 max(db(Up))+10]);
            figure_nr=figure_nr+1;
        end        
    end
    
end
